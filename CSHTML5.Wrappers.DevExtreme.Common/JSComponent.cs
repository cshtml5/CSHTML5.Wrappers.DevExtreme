using CSHTML5.Native.Html.Controls;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
#if SLMIGRATION
using System.Windows;
#else
using Windows.UI.Xaml;
#endif

namespace CSHTML5.Wrappers.DevExtreme.Common
{
    /// <summary>
    /// Base class providing a standard way to expose a JS component as a C#/XAML component.
    /// </summary>
    /// <remarks>
    /// This class should be derived whenever possible when designing a library exposing a JS component, because:
    /// <list type="number">
    /// <item>
    /// It ensures that the class exposing the component implements the correct initialization logic
    /// for the underlying JS instance.
    /// </item>
    /// <item>
    /// It is designed to integrate well with C# code generated by the compiler from TypeScript definitions.
    /// </item>
    /// <item>
    /// It makes it easier to provide a consistent API across all libraries of this kind.
    /// </item>
    /// </list>
    /// However, one might need its component to derive from a different class than HtmlPresenter.
    /// In this case, it is advised to reproduce most of the functionality provided by JSComponent
    /// in your class to keep the aforementioned benefits.
    /// </remarks>
    public abstract class JSComponent : HtmlPresenter
    {
        bool initJSInstance = false;
        readonly TaskCompletionSource<bool> jsInstanceLoaded = new TaskCompletionSource<bool>();

        /// <value>
        /// JS Library that must be loaded before this component.
        /// </value>
        /// <remarks>
        /// This should be implemented as a reference to a static field
        /// to avoid loading the same files multiple times.
        /// </remarks>
        public abstract JSLibrary JSLibrary { get; }

        /// <value>
        /// Task providing a way for users to wait for the initialization of this component's underlying JS instance.
        /// </value>
        public Task<bool> JSInstanceLoaded { get { return jsInstanceLoaded.Task; } }

        /// <summary>
        /// Initializes the HTML content of this component, as well as its underlying JS instance
        /// as soon as the component has finished loading in the Visual Tree.
        /// </summary>
        /// <param name="initJSInstance">
        /// Whether the InitializeJSInstance method should be used to initialize the underlying JS instance.
        /// </param>
        /// <remarks>
        /// When working with C# code generated by the compiler from TypeScript definitions, this method
        /// should be called in every overload of the partial Initialize method so that it will be called
        /// in every constuctor.
        /// The initJSInstance parameter is useful when straying apart from the instanciation scenarios
        /// provided by the JS library of the component.
        /// </remarks>
        protected void Initialize(bool initJSInstance = false)
        {
            this.initJSInstance = initJSInstance;

            this.Html = this.InitializeHtml();
            this.Loaded += this.JSComponent_Loaded;
            this.Unloaded += this.JSComponent_Unloaded;
        }

        /// <summary>
        /// Generates the initial HTML content of this component.
        /// </summary>
        /// <returns>
        /// A string holding the initial HTML.
        /// </returns>
        protected virtual string InitializeHtml()
        {
            return @"<div style='width: 100%; height: 100%;'>";
        }

        /// <summary>
        /// Custom code to execute to initialize this component's underlying JS instance.
        /// </summary>
        /// <remarks>
        /// This method will be executed by the Initialize method if its initJSInstance parameter is set to true.
        /// The latter defaults to false because most of the time, instanciation will be handled by the constructor
        /// auto-generated by the compiler from the TypeScript definition of the component.
        /// </remarks>
        protected virtual void InitializeJSInstance()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Custom code to execute after the underlying JS instance has finished loading.
        /// </summary>
        /// This method is required because it is not possible in CSHTML5 to wait for a task
        /// inside of a synchronous method, and thus we cannot await JSInstanceLoaded in the
        /// partial Initialize method auto-generated by the compiler.
        protected virtual void OnJSInstanceLoaded()
        {
            // Do nothing by default.
        }

        protected virtual async void JSComponent_Loaded(object sender, RoutedEventArgs e)
        {
            await this.JSLibrary.Load();
            if (this.JSLibrary.IsLoaded)
            {
                if (this.initJSInstance)
                    this.InitializeJSInstance();
                // Using a Dispatcher because we need the component to be fully loaded before being able to properly modify the visual tree (we might meet uninitialized elements otherwise).
                // before this fix (2019/01/28), the Sample Showcase can display such an error when clicking on Third Party -> Telerik Kendo UI -> Grid then reclicking Grid
                Dispatcher.BeginInvoke(() =>
                {
                    this.jsInstanceLoaded.SetResult(true);

                    this.OnJSInstanceLoaded();
                });
            }
            else
            {
                this.jsInstanceLoaded.SetResult(false);
            }
        }

        protected void AbortLoading()
        {
            this.jsInstanceLoaded.SetResult(false);
        }

        /// <summary>
        /// Custom code to execute after the underlying JS instance has finished loading.
        /// </summary>
        /// This method is required because it is not possible in CSHTML5 to wait for a task
        /// inside of a synchronous method, and thus we cannot await JSInstanceLoaded in the
        /// partial Initialize method auto-generated by the compiler.
        protected virtual void OnJSInstanceUnloaded()
        {
            // Do nothing by default.
        }

        void JSComponent_Unloaded(object sender, RoutedEventArgs e)
        {
            this.OnJSInstanceUnloaded();
        }
    }
}
